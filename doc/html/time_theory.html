

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Time-domain Analysis &mdash; Speakerbench 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/contentui.css?v=4cf5b151" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=a0fb6060" />

  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=2709fde1"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="_static/contentui.js?v=9ee86694"></script>
      <script>window.MathJax = {"tex": {"macros": {"qt": "{Q_\\mathrm{TS}}", "qes": "{Q_\\mathrm{ES}}", "qms": "{Q_\\mathrm{MS}}", "qa": "{Q_\\mathrm{{\\hspace -1pt} A}}", "bl": "{B\\ell}", "bls": "{(B\\ell)^2}", "mms": "{M_\\mathrm{MS}}", "mmp": "{M_\\mathrm{MP}}", "cms": "{C_\\mathrm{MS}}", "rms": "{R_\\mathrm{MS}}", "cmb": "{C_\\mathrm{MB}}", "wmin": "{\\omega_\\mathrm{min}}", "wmax": "{\\omega_\\mathrm{max}}", "tp": "{t^\\prime}", "dmn": "{\\Delta_{mn}}", "vb": "{V_\\mathrm{B}}", "vas": "{V_\\mathrm{AS}}", "vp": "{V_\\mathrm{P}}", "cab": "{C_\\mathrm{AB}}", "map": "{M_\\mathrm{AP}}", "ma": "{M_\\mathrm{A}}", "sd": "{S_\\mathrm{D}}", "ad": "{a_\\mathrm{D}}", "sp": "{S_\\mathrm{P}}", "ap": "{a_\\mathrm{P}}", "sb": "{S_\\mathrm{B}}", "caf": "{C_\\mathrm{af}}", "cth": "{C_\\mathrm{th}}", "cua": "{C_\\mathrm{ua}}", "raf": "{R_\\mathrm{af}}", "rth": "{R_\\mathrm{th}}", "cfu": "{C^*_\\mathrm{AB}}", "rfu": "{R^*_\\mathrm{AB}}", "ws": "{\\omega_\\mathrm{S}}", "fp": "{f_\\mathrm{P}}", "wp": "{\\omega_\\mathrm{P}}", "lp": "{l_\\mathrm{P}}", "fs": "{f_\\mathrm{S}}", "fcb": "{f_\\mathrm{CB}}", "qtc": "{Q_\\mathrm{TC}}", "deltv": "{\\delta_v}", "xs": "{x_\\mathrm{S}}", "xim": "{x_\\mathrm{I}}", "xmax": "{X_\\mathrm{max}}", "re": "{R_\\mathrm{E}}", "leb": "{L_\\mathrm{EB}}", "le": "{L_\\mathrm{E}}", "ke": "{K_\\mathrm{E}}", "rss": "{R_\\mathrm{SS}}", "zm": "{Z_\\mathrm{M}}", "zms": "{Z_{\\mathrm{M}*}}", "zin": "{Z}", "ze": "{Z_\\mathrm{E}}", "cmes": "{C_\\mathrm{MES}}", "res": "{R_\\mathrm{ES}}", "lces": "{L_\\mathrm{CES}}", "cas": "{C_\\mathrm{AS}}", "fr": "{g}", "ql": "{\\sigma}", "rlog": "{R_0}", "clog": "{C_0}", "llog": "{L_0}", "flog": "{f_0}", "ssa": "{\\mathrm{SS}_A}", "sse": "{\\mathrm{SS}_E}", "msa": "{\\mathrm{MS}_A}", "mse": "{\\mathrm{MS}_E}", "mmf": "{M_\\mathrm{MF}}", "mmr": "{M_\\mathrm{MR}}", "hz": "{\\textrm{Hz}}", "khz": "{\\textrm{kHz}}", "cm": "{\\textrm{cm}}", "gr": "{\\textrm{g}}", "mg": "{\\textrm{mg}}", "mv": "{\\textrm{mV}}", "mw": "{\\textrm{mW}}", "mh": "{\\textrm{mH}}", "tm": "{\\textrm{Tm}}", "kgm": "{\\textrm{kg/m}^3 \\,}", "mps": "{\\textrm{m/s}}", "heatcap": "{\\textrm{J/(kg K)}}", "taue": "{\\tau_e}", "tauv": "{\\tau_v}"}}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Sample Data" href="sampledata.html" />
    <link rel="prev" title="The CD4 Bass Reflex Alignment" href="cd4.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Speakerbench
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quickstart</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Impedance</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="measure.html">Impedance Measurement</a></li>
<li class="toctree-l1"><a class="reference internal" href="collect.html">Impedance Data Object</a></li>
<li class="toctree-l1"><a class="reference internal" href="fit.html">Advanced Model Fit</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Box Modeling</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="create.html">Create datasheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="box.html">Box Simulation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Theory Notes</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="deltamass_theory.html">Dual-Added-Mass Method</a></li>
<li class="toctree-l1"><a class="reference internal" href="alignment_theory.html">Classic Vented Alignments</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Time-domain Analysis</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-problem-and-the-solution">The problem and the solution</a></li>
<li class="toctree-l2"><a class="reference internal" href="#response-function-representation">Response function representation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#impulse-response">Impulse response</a></li>
<li class="toctree-l3"><a class="reference internal" href="#step-response">Step response</a></li>
<li class="toctree-l3"><a class="reference internal" href="#general-system-response">General system response</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#application-to-transducer-response">Application to transducer response</a></li>
<li class="toctree-l2"><a class="reference internal" href="#weideman-method">Weideman method</a></li>
<li class="toctree-l2"><a class="reference internal" href="#application-to-box-response">Application to box response</a></li>
<li class="toctree-l2"><a class="reference internal" href="#result-with-viscoelastic-suspension">Result with viscoelastic suspension</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nonlinear-driver-simulation">Nonlinear driver simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#summary-of-inversion-method">Summary of inversion method</a></li>
<li class="toctree-l2"><a class="reference internal" href="#appendices">Appendices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#simplification-of-the-ritter-3pc-compliance-model">Simplification of the Ritter 3PC compliance model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sample-python-code-for-inverse-transform">Sample Python code for inverse transform</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Resources</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="sampledata.html">Sample Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="youtube.html">YouTube</a></li>
<li class="toctree-l1"><a class="reference internal" href="json-docs.html">JSON Datafile Definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary of symbols</a></li>
<li class="toctree-l1"><a class="reference internal" href="zreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Speakerbench</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Time-domain Analysis</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/time_theory.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
  .ss-layout-default-A { grid-template-areas: 'A'; }
  .ss-layout-default-ABC { grid-template-areas: 'A B C'; }
  .ss-layout-default-AB { grid-template-areas: 'A B'; }
</style>
<section id="time-domain-analysis">
<span id="time-theory"></span><h1>Time-domain Analysis<a class="headerlink" href="#time-domain-analysis" title="Link to this heading"></a></h1>
<section id="the-problem-and-the-solution">
<h2>The problem and the solution<a class="headerlink" href="#the-problem-and-the-solution" title="Link to this heading"></a></h2>
<p>A fundamental aspect of loudspeaker modeling is the ability to calculate the time-domain response of a driver in free air, or in a specified enclosure, given prior calculation of the frequency response.   Whereas the low-frequency electroacoustic theory of Benson, Thiele and Small  may be used to compute the steady-state pressure (SPL), velocity and excursion of a loudspeaker as a function of frequency, it remains to compute the time-domain impulse and step responses by inverse Laplace transform. This is done analytically by Benson <span id="id1">[<a class="reference internal" href="zreferences.html#id8" title="J.E. Benson. Theory and Design of Loudspeaker Enclosures. Synergetic Audio Concepts (with permission from Dr. J.E. Benson and Amalgamated Wireless Australasia Technical Review), 1993.">Ben93</a>]</span> for simple closed boxes by decomposing the <span class="math notranslate nohighlight">\(s\)</span>-domain response function into a sum of poles such that the Laplace transform can be inverted using exponential and related functions. For more complicated polynomial filters, numerical methods based on computing eigenvalues of the companion matrix are often used.  This approach does not generalize to non-polynomial response functions which inevitably require a numerical treatment, most often by discrete Fourier inversion methods.</p>
<p>In these notes we describe a numerical approach to invert Laplace transforms required for computation of the time-domain response of loudspeakers.  The method is an adaptation of the method of Weideman <span id="id2">[<a class="reference internal" href="zreferences.html#id64" title="J.A.C. Weideman and L.N. Trefethen. Parabolic and hyperbolic contours for computing the bromwich integral. Math Comput., 76:1341, 2007.">WT07</a>]</span>, with suitable modifications to accomodate the analytic structure found in typical audio applications.  In comparison to Fourier method, however, the Weideman method is significantly more efficient and accurate, yet it is straightforward to implement without the need for third-party mathematical libraries.  Thus it can be implemented in existing box-modeling software with little effort.</p>
</section>
<section id="response-function-representation">
<h2>Response function representation<a class="headerlink" href="#response-function-representation" title="Link to this heading"></a></h2>
<p>Consider the driven linear system</p>
<div class="math notranslate nohighlight" id="equation-eq-basic">
<span class="eqno">(13)<a class="headerlink" href="#equation-eq-basic" title="Link to this equation"></a></span>\[{\cal D} \, x(t) = f(t) \; ,\]</div>
<p>where <span class="math notranslate nohighlight">\(x\)</span> is a generalized displacement, <span class="math notranslate nohighlight">\(f\)</span> is a generalized force, and <span class="math notranslate nohighlight">\({\cal D}\)</span> is a linear operator.  We remark that <span class="math notranslate nohighlight">\({\cal D}\)</span> can contain integrals, derivatives or fractional derivatives.   Taking the Laplace transform of Eq. <a class="reference internal" href="#equation-eq-basic">(13)</a> and solving for <span class="math notranslate nohighlight">\(X(s)\)</span> yields the response function form of the linear system:</p>
<div class="math notranslate nohighlight">
\[X(s) = R(s) F(s) \; .\]</div>
<p>Here, <span class="math notranslate nohighlight">\(X(s)\)</span> and <span class="math notranslate nohighlight">\(F(s)\)</span> are the Laplace transforms of <span class="math notranslate nohighlight">\(x(t)\)</span> and <span class="math notranslate nohighlight">\(f(t)\)</span>,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{eqnarray}
X(s) &amp; = &amp; {\cal L}[x] \doteq \int_0^\infty dt \, e^{-st} x(t) \; , \\
F(s) &amp; = &amp; {\cal L}[f] \doteq \int_0^\infty dt \, e^{-st} f(t) \; .
\end{eqnarray}\end{split}\]</div>
<p>and <span class="math notranslate nohighlight">\(R(s)\)</span> is the response function.  One can solve for <span class="math notranslate nohighlight">\(x(t)\)</span> by inverting the Laplace transform</p>
<div class="math notranslate nohighlight">
\[x(t) = {\cal L}^{-1} \left[ R(s) F(s) \right] \; ,\]</div>
<p>where the inverse is defined in terms of the Bromwich integral</p>
<div class="math notranslate nohighlight" id="equation-eq-brom">
<span class="eqno">(14)<a class="headerlink" href="#equation-eq-brom" title="Link to this equation"></a></span>\[x(t) = {\cal L}^{-1} \left[ X \right] \doteq \frac{1}{2 \pi i} \int_{\sigma-i\infty}^{\sigma+i\infty} ds \, e^{st} X(s) \; .\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\sigma\)</span> is chosen so that the contour lies to the right of all singularities of the integrand, as illustrated in <a class="reference internal" href="#zplane"><span class="std std-numref">Fig. 11</span></a>.  So long as the contour remains to the right of these singularities, the Cauchy integral theorem <span id="id3">[<a class="reference internal" href="zreferences.html#id24" title="R.E. Greene and S.G. Krantz. Function Theory of One Complex Variable. American Mathematical Society, 2006.">GK06</a>]</span> guarantees that the value of the integral is independent of the path of integration.</p>
<figure class="sphinx-subfigure align-center" id="zplane" style="width: 50%">
<div class="sphinx-subfigure-grid ss-layout-default-A" style="display: grid;">
<div class="sphinx-subfigure-area" style="display: flex; flex-direction: column; justify-content: center; align-items: center; grid-area: A;">
<img alt="_images/zplane.png" src="_images/zplane.png" />
</div>
</div>
<figcaption>
<p><span class="caption-number">Fig. 11 </span><span class="caption-text">Complex plane illustrating Bromwich inversion contour (dashed line) for a hypothetical case.  The contour must lie to the right of all poles and branch cuts.  Also shown is the unit circle, poles typical of a 4th order Butterworth filter, and a branch cut (wavy curve) at <span class="math notranslate nohighlight">\(s=0\)</span>.</span><a class="headerlink" href="#zplane" title="Link to this image"></a></p>
</figcaption>
</figure>
<section id="impulse-response">
<h3>Impulse response<a class="headerlink" href="#impulse-response" title="Link to this heading"></a></h3>
<p>The impulse response is generated using the Dirac delta function <span class="math notranslate nohighlight">\(\delta(t)\)</span> as the driving force:</p>
<div class="math notranslate nohighlight">
\[f(t) = \delta(t) \Longleftrightarrow F(s) = 1 \; .\]</div>
<p>The required inverse transform is thus</p>
<div class="math notranslate nohighlight">
\[\xim(t) =  {\cal L}^{-1} \left[R(s)\right] \; .\]</div>
<p>In the solution of inhomogeneous differential equations, when <span class="math notranslate nohighlight">\(\cal{D}\)</span> is a linear differential operator, the impulse response <span class="math notranslate nohighlight">\(\xim\)</span> is equivalently called the <em>Green’s function</em> for <a class="reference internal" href="#equation-eq-basic">(13)</a>.</p>
</section>
<section id="step-response">
<h3>Step response<a class="headerlink" href="#step-response" title="Link to this heading"></a></h3>
<p>The step response is generated using the Heaviside step function <span class="math notranslate nohighlight">\(H(t)\)</span> as the driving force:</p>
<div class="math notranslate nohighlight">
\[f(t) = H(t) \Longleftrightarrow F(s) = 1/s\]</div>
<p>The required inverse transform is thus</p>
<div class="math notranslate nohighlight">
\[\xs(t) =  {\cal L}^{-1} \left[\frac{R(s)}{s}\right]\]</div>
<p>The step and delta functions are related according to</p>
<div class="math notranslate nohighlight">
\[\frac{dH}{dt} \doteq \dot{H} = \delta(t) \; ,\]</div>
<p>where this formula is rigorously justified in terms of generalized functions <span id="id4">[<a class="reference internal" href="zreferences.html#id67" title="A.H. Zemanian. Distribution Theory and Transform Analysis. McGraw-Hill, New York, 1965.">Zem65</a>]</span>.  Note that, in this paper, a dot denotes a time derivative.</p>
</section>
<section id="general-system-response">
<h3>General system response<a class="headerlink" href="#general-system-response" title="Link to this heading"></a></h3>
<p>Using the convolution property of the inverse transform, it is easy to show that</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{eqnarray}
x(t) &amp;=&amp; \int_0^t d\tp \, \xim(\tp) f(t-\tp) \; , \\
&amp;=&amp; \int_0^t d\tp \, \xs(\tp) \dot{f}(t-\tp) \; .
\end{eqnarray}\end{split}\]</div>
<p>Evidently, one can also compute the step response by integration of the impulse response,</p>
<div class="math notranslate nohighlight">
\[\xs(t) = \int_0^t d\tp \, \xim(\tp) \; .\]</div>
<p>A simple example outlining the calculation of impulse and step responses for a simple linear oscillator is given in the Appendix. In the following sections we will focus on the step response, <span class="math notranslate nohighlight">\(\xs\)</span>, because it avoids the singularity present in the impulse response.  The step response is typically computed in box modeling programs.</p>
</section>
</section>
<section id="application-to-transducer-response">
<h2>Application to transducer response<a class="headerlink" href="#application-to-transducer-response" title="Link to this heading"></a></h2>
<p>In the present paper, we choose to formulate the inverse problem using a dimensionless time <span class="math notranslate nohighlight">\(t = \omega_s \tau\)</span>, where <span class="math notranslate nohighlight">\(\tau\)</span> is the physical time, and <span class="math notranslate nohighlight">\(\omega_s = 2 \pi f_s\)</span> is the resonant frequency of the loudspeaker driver.  To illustrate the inversion process for a simple case, we consider the steady-state pressure response for an undamped, closed box <span id="id5">[<a class="reference internal" href="zreferences.html#id8" title="J.E. Benson. Theory and Design of Loudspeaker Enclosures. Synergetic Audio Concepts (with permission from Dr. J.E. Benson and Amalgamated Wireless Australasia Technical Review), 1993.">Ben93</a>]</span>. In this case, the response function takes the form of a 2nd-order high-pass filter</p>
<div class="math notranslate nohighlight" id="equation-eq-hp2">
<span class="eqno">(15)<a class="headerlink" href="#equation-eq-hp2" title="Link to this equation"></a></span>\[R(s) = \frac{s^2}{\displaystyle s^2 + \frac{s}{\qt} + 1 + \alpha} \; ,\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha \doteq \cms/\cmb\)</span> is the compliance ratio and <span class="math notranslate nohighlight">\(\qt\)</span> is the driver total <span class="math notranslate nohighlight">\(Q\)</span>.  In these expressions, <span class="math notranslate nohighlight">\(\cms\)</span> is the mechanical compliance of the driver suspension, and <span class="math notranslate nohighlight">\(\cmb\)</span> is the equivalent mechanical compliance of the interior of the closed box.  Further, <span class="math notranslate nohighlight">\(1/\qt = 1/\qes + 1/\qms\)</span>, where <span class="math notranslate nohighlight">\(\qes\)</span> and <span class="math notranslate nohighlight">\(\qms\)</span> are the electrical and mechanical <span class="math notranslate nohighlight">\(Q\)</span> factors of the driver.</p>
<p>For the special choice of <span class="math notranslate nohighlight">\(\alpha=0\)</span> (i.e., the infinite baffle limit <span class="math notranslate nohighlight">\(\cmb \rightarrow \infty\)</span>) and <span class="math notranslate nohighlight">\(\qt = 0.5\)</span>, we can write the inversion integral for the step response as</p>
<div class="math notranslate nohighlight" id="equation-eq-simple">
<span class="eqno">(16)<a class="headerlink" href="#equation-eq-simple" title="Link to this equation"></a></span>\[\xs(t) = \frac{1}{2 \pi i} \int_{\sigma-i\infty}^{\sigma+i\infty} ds \, e^{st}
\, \frac{s}{s^2 + 2s + 1} \; .\]</div>
<p>The integrand contains a pole of order 2 at <span class="math notranslate nohighlight">\(s=-1\)</span>, in which case we can close the contour to the left and use the residue theorem to give</p>
<div class="math notranslate nohighlight" id="equation-eq-residue">
<span class="eqno">(17)<a class="headerlink" href="#equation-eq-residue" title="Link to this equation"></a></span>\[\xs(t) = \frac{\partial}{\partial s}\left. \left(s e^{st}\right) \right|_{s = -1} = e^{-t} (1-t) \; .\]</div>
<p>In the more realistic case of vented and damped enclosures, the same method based on analytic contour integration will work in principle, although locating the poles and computing residues may become tedious and complicated.  In practical cases, the residue calculation is done numerically by computing eigenvalues of the <em>companion matrix</em> <span id="id6">[<a class="reference internal" href="zreferences.html#id17" title="A. Edelman and H. Murakami. Polynomial roots from companion matrix eigenvalues. Math Comput., 64:763, 1995.">EM95</a>]</span>.  Importantly, the residue-based methods described above are applicable only to rational functions, and fail in the general case for which the driver circuit model contains semi-inductance <span id="id7">[<a class="reference internal" href="zreferences.html#id59" title="K. Thorborg and C. Futtrup. Electrodynamic Transducer Model Incorporating Semi-Inductance and Means for Shorting AC Magnetization. J. Audio. Eng. Soc., 59:612, 2011. URL: http://www.aes.org/e-lib/browse.cfm?elib=15978.">TF11</a>]</span> or viscoelastic creep <span id="id8">[<a class="reference internal" href="zreferences.html#id32" title="M.H. Knudsen and J.G. Jensen. Low-frequency loudspeaker models that include suspension creep. J. Audio. Eng. Soc., 41:3, 1993. URL: http://www.aes.org/e-lib/browse.cfm?elib=7015.">KJ93</a>, <a class="reference internal" href="zreferences.html#id41" title="A. Novak. Modeling viscoelastic properties of loudspeaker suspensions using fractional derivatives. J. Audio. Eng. Soc., 64:35, 2016. doi:10.17743/jaes.2015.0091.">Nov16</a>, <a class="reference internal" href="zreferences.html#id60" title="K. Thorborg and C. Futtrup. Frequency Dependence of the Loudspeaker Suspension (A Follow-Up). J. Audio. Eng. Soc., 61:778, 2013.">TF13</a>, <a class="reference internal" href="zreferences.html#id58" title="K. Thorborg, C. Tinggaard, F. Agerkvist, and C. Futtrup. Frequency Dependence of Damping and Compliance in Loudspeaker Suspensions. J. Audio. Eng. Soc., 58:472, 2010.">TTAF10</a>]</span>. In this case the frequency-domain response function will contain elements described by functions with branch points – for example, <span class="math notranslate nohighlight">\(\sqrt{s}\)</span> or <span class="math notranslate nohighlight">\(\ln(s)\)</span>.  One must then return to the Bromwich integral in Eq. <a class="reference internal" href="#equation-eq-brom">(14)</a> and perform the contour integration numerically.</p>
<p>The problem of numerical inversion of the Laplace transform has been an active area of research since the 1960s <span id="id9">[<a class="reference internal" href="zreferences.html#id7" title="R.E. Bellman, H.H. Kagiwada, and R.E. Kalaba. Numerical inversion of laplace transforms and some inverse problems in radiative transfer. J. Atmos. Sci., 23:555, 1966.">BKK66</a>]</span>, with an important method developed by Talbot in 1979 <span id="id10">[<a class="reference internal" href="zreferences.html#id55" title="A. Talbot. The Accurate Numerical Inversion of Laplace Transforms. J. Inst. Math. Appl., 23:97, 1979.">Tal79</a>]</span>.  There is no single best method; rather, the most suitable method will in general depend on the nature of the problem. To illustrate the convergence issues associated with inversion of the transform, consider again the example of Eq. <a class="reference internal" href="#equation-eq-simple">(16)</a>.  As a straightforward attempt to evaluate the Bromwich integral directly, one can put the integration contour on the imaginary axis <span class="math notranslate nohighlight">\(s=iy\)</span>.  In this case the Bromwich integral, Eq. <a class="reference internal" href="#equation-eq-simple">(16)</a>, reduces to the inverse Fourier transform</p>
<div class="math notranslate nohighlight" id="equation-eq-ift">
<span class="eqno">(18)<a class="headerlink" href="#equation-eq-ift" title="Link to this equation"></a></span>\[\xs(t) = \frac{1}{2\pi} \int_{-\infty}^\infty dy \, e^{i y t} \, \frac{iy}{(iy)^2 + 2iy + 1} \; .\]</div>
<p>The conversion of the Bromwich integral to a Fourier integral is always possible when the singularities of the transfer function lie in the left half-plane (i.e., when the linear system is textit{stable}).  This integral can be performed analytically to yield</p>
<div class="math notranslate nohighlight" id="equation-eq-direct">
<span class="eqno">(19)<a class="headerlink" href="#equation-eq-direct" title="Link to this equation"></a></span>\[\begin{split}\begin{eqnarray}
\xs(t)
&amp; = &amp;~ \frac{1}{\pi} \int_0^\infty dy \, \frac{2y^2 \cos(yt) + (y^3-y) \sin(yt)}{(1+y^2)^2} \; , \\
&amp; = &amp;~ e^{-t} (1-t) \; .
\end{eqnarray}\end{split}\]</div>
<p>As required, the analytic solution in Eq. <a class="reference internal" href="#equation-eq-direct">(19)</a>, obtained by directvintegration of the infinite (Fourier) integral, is the same as that obtained in Eq. <a class="reference internal" href="#equation-eq-residue">(17)</a> by contour integration.  However, consideration of the Fourier integral above reveals a serious deficiency; namely, that the integral decays very slowly at large values of <span class="math notranslate nohighlight">\(y\)</span>:</p>
<div class="math notranslate nohighlight">
\[\frac{2y^2 \cos(yt) + (y^3-y) \sin(yt)}{(1+y^2)^2} \sim \frac{\sin(yt)}{y}
\; \text{as}\; y \rightarrow \infty \; .\]</div>
<p>Thus, at small times <span class="math notranslate nohighlight">\(t \ll 1\)</span>, extremely large values of <span class="math notranslate nohighlight">\(y\)</span> (i.e., very high frequencies in the Fourier sense) must be retained to accurately evaluate the integral.  This is in contrast to the previous contour integration, which can determine the integral exactly via any closed contour surrounding the pole at <span class="math notranslate nohighlight">\(s = iy = -1\)</span>.  The implication is that a numerical method based on integration along a vertical contour will be fundamentally inefficient, quite independent of the numerical quadrature method.  Let us take this illustration further by explicitly constructing a numerical inversion, via <em>inverse discrete Fourier transform</em> (iDFT), and rewrite the integral as</p>
<div class="math notranslate nohighlight" id="equation-eq-cont">
<span class="eqno">(20)<a class="headerlink" href="#equation-eq-cont" title="Link to this equation"></a></span>\[\xs(t) = \int_{-\wmax}^{\wmax} dy \, e^{iyt} \frac{R(iy)}{iy} + E(\wmax) \; .\]</div>
<p>Above, <span class="math notranslate nohighlight">\(E(\wmax)\)</span> is the error resulting from truncation of the limits of integration, and, as before, <span class="math notranslate nohighlight">\(R(s) = s^2/(s^2+2s+1)\)</span>.  If we let <span class="math notranslate nohighlight">\(t_n = n \Delta t\)</span> and <span class="math notranslate nohighlight">\(y_k = k \Delta y\)</span> then</p>
<div class="math notranslate nohighlight" id="equation-eq-dft">
<span class="eqno">(21)<a class="headerlink" href="#equation-eq-dft" title="Link to this equation"></a></span>\[x_n = \sum_{k=-N/2}^{N/2-1} e^{2\pi i kn/N} \, G_k \; , \quad n = 0, \ldots, N-1 \; ,\]</div>
<p>where <span class="math notranslate nohighlight">\(x_n\)</span> is an approximation to <span class="math notranslate nohighlight">\(\xs(t_n)\)</span>, <span class="math notranslate nohighlight">\(G_k = R(ik\Delta y)/(ik)\)</span>, <span class="math notranslate nohighlight">\(\wmax = N \Delta y/2\)</span>, and <span class="math notranslate nohighlight">\(\Delta y \Delta t = 2\pi/ N\)</span>.  Eq. <a class="reference internal" href="#equation-eq-dft">(21)</a> thus expresses <span class="math notranslate nohighlight">\(x_n\)</span> as the
iDFT of <span class="math notranslate nohighlight">\(G_k\)</span>.  In the limit <span class="math notranslate nohighlight">\(N \rightarrow \infty\)</span>, <span class="math notranslate nohighlight">\(x_n\)</span> will exactly recover the finite integral in Eq. <a class="reference internal" href="#equation-eq-cont">(20)</a>, but will always differ from <span class="math notranslate nohighlight">\(\xs(t_n)\)</span> by the truncation error <span class="math notranslate nohighlight">\(E(\wmax)\)</span>. To illustrate the poor accuracy obtained in a typical case, consider a transducer with <span class="math notranslate nohighlight">\(f_s = 100\)</span> Hz and choose <span class="math notranslate nohighlight">\(f_\mathrm{max} = 32\)</span> kHz and <span class="math notranslate nohighlight">\(n=8000\)</span>. Then</p>
<div class="math notranslate nohighlight">
\[|\xs(t_n) - x_n| \sim E(\wmax) \sim 1.5 \times 10^{-3} \; ,\]</div>
<p>when <span class="math notranslate nohighlight">\(t_n \sim 0.1\)</span>.  Considering the very high resolution, this is a surprisingly large truncation error.  The error is not a consequence of any particular deficiency of the iDFT itself, but rather of the vertical Fourier contour.  This issue is well-recognized in the literature and numerous methods to overcome the poor convergence have been developed.</p>
</section>
<section id="weideman-method">
<h2>Weideman method<a class="headerlink" href="#weideman-method" title="Link to this heading"></a></h2>
<p>Instead of the vertical contour, we will use an approach based on deforming the contour into the left half-plane.  Although the basic approach is due to Talbot <span id="id11">[<a class="reference internal" href="zreferences.html#id55" title="A. Talbot. The Accurate Numerical Inversion of Laplace Transforms. J. Inst. Math. Appl., 23:97, 1979.">Tal79</a>]</span>, we use the more recent optimal method due to Weideman <span id="id12">[<a class="reference internal" href="zreferences.html#id64" title="J.A.C. Weideman and L.N. Trefethen. Parabolic and hyperbolic contours for computing the bromwich integral. Math Comput., 76:1341, 2007.">WT07</a>]</span>, with modifications to suit the problem of loudspeaker response.  It should be emphasized that application of the method requires the response function to be known as an analytic function of the complex variable <span class="math notranslate nohighlight">\(s\)</span>.</p>
<p>Weideman treats both a parabolic and hyperbolic contour, but we consider only the parabolic one:</p>
<div class="math notranslate nohighlight" id="equation-eq-parabola">
<span class="eqno">(22)<a class="headerlink" href="#equation-eq-parabola" title="Link to this equation"></a></span>\[s(u) = \mu \left( i u + 1 \right)^2 \, , \quad - \infty &lt; u &lt; \infty \; .\]</div>
<p>The integration rule is trapezoidal</p>
<div class="math notranslate nohighlight" id="equation-eq-trap">
<span class="eqno">(23)<a class="headerlink" href="#equation-eq-trap" title="Link to this equation"></a></span>\[\xs(t) = \frac{\Delta}{2\pi i} \sum_{k=-N}^N e^{s_k t} \frac{R(s_k)}{s_k} s^\prime(u_k) \; ,\]</div>
<p>where <span class="math notranslate nohighlight">\(s_k \doteq s(u_k)\)</span>, <span class="math notranslate nohighlight">\(s^\prime = ds/du = 2\mu(i-u)\)</span> and <span class="math notranslate nohighlight">\(u_k = k \Delta\)</span>. Although
Eq. <a class="reference internal" href="#equation-eq-trap">(23)</a> provides a discrete approximation to the integral for any values of <span class="math notranslate nohighlight">\(\Delta\)</span> and <span class="math notranslate nohighlight">\(\mu\)</span>, Weideman shows that the optimal parameters for the parabolic contour are</p>
<div class="math notranslate nohighlight" id="equation-eq-hmu">
<span class="eqno">(24)<a class="headerlink" href="#equation-eq-hmu" title="Link to this equation"></a></span>\[\Delta_\mathrm{opt} = \frac{3}{N} \quad \text{and} \quad \mu_\mathrm{opt} = \frac{\pi}{12} \frac{N}{t} \; .\]</div>
<p>So long as the contour is acceptable (not passing through singularities during deformation into the parabola), the method is remarkably accurate.  We remark that the algorithm can be applied for any value of <span class="math notranslate nohighlight">\(t &gt; 0\)</span>, and the optimal parameters must be recomputed for every value of :math:t$ according to Eq. <a class="reference internal" href="#equation-eq-hmu">(24)</a>. In Ref. <span id="id13">[<a class="reference internal" href="zreferences.html#id64" title="J.A.C. Weideman and L.N. Trefethen. Parabolic and hyperbolic contours for computing the bromwich integral. Math Comput., 76:1341, 2007.">WT07</a>]</span>, the emphasis is on solving problems for which singularities lie on the negative real axis, in which case there are no restrictions on the smallness of <span class="math notranslate nohighlight">\(\mu\)</span>.  For <span class="math notranslate nohighlight">\(t\)</span> sufficiently large, however, the magnitude of <span class="math notranslate nohighlight">\(\mu_\mathrm{opt}\)</span> will shrink so much that a pole is crossed.  Since we expect poles approximately in the range <span class="math notranslate nohighlight">\(|s| \sim 1\)</span> (for example, a Butterworth filter has all poles on the left half of the unit circle), we must ensure that <span class="math notranslate nohighlight">\(2 \mu &gt; y_\mathrm{max}\)</span>, where <span class="math notranslate nohighlight">\(y_\mathrm{max}\)</span> is the maximum height of a pole, and <span class="math notranslate nohighlight">\(2 \mu\)</span> is the point at which upper-half of the parabola intersects the imaginary axis.  To see this, note from Eq. <a class="reference internal" href="#equation-eq-parabola">(22)</a> that <span class="math notranslate nohighlight">\(s(1) = \mu (1+i)^2 = 2i\mu\)</span>.</p>
</section>
<section id="application-to-box-response">
<h2>Application to box response<a class="headerlink" href="#application-to-box-response" title="Link to this heading"></a></h2>
<p>To modify the Weideman algorithm to prevent pole crossing, it is instructive to consider in detail the behaviour of the response function for an undamped, vented box.  This is written as</p>
<div class="math notranslate nohighlight">
\[R(s) = \frac{s^4}{\displaystyle \left(s^2+h^2\right) \left( 1 + \frac{s}{\qt} + s^2\right)
 + \alpha s^2} \; .\]</div>
<p>The new parameter <span class="math notranslate nohighlight">\(h=\omega_p/\omega_s\)</span>, where <span class="math notranslate nohighlight">\(\omega_p\)</span> is resonant frequency of the vented enclosure, transforms the response into a 4th-order filter with four poles in the left half-plane.   Small <span id="id14">[<a class="reference internal" href="zreferences.html#id51" title="R.H. Small. Vented-Box Loudspeaker Systems Part 1: Small-Signal Analysis. J. Audio. Eng. Soc., 21:363, 1973. URL: http://www.aes.org/e-lib/browse.cfm?elib=1967.">Sma73a</a>]</span> refers to <span class="math notranslate nohighlight">\(h\)</span> as the <em>system tuning ratio</em>.  Typical vented alignments choose <span class="math notranslate nohighlight">\(h \sim 1\)</span>. The pole locations for this response function can be computed analytically in some
special cases – most notably when the denominator coincides with the 4th-order Butterworth polynomial:</p>
<div class="math notranslate nohighlight" id="equation-eq-but">
<span class="eqno">(25)<a class="headerlink" href="#equation-eq-but" title="Link to this equation"></a></span>\[\begin{split}\begin{eqnarray}
h^2 &amp; = &amp; 1 , \; \alpha = \sqrt{2} \\
1/\qt &amp; = &amp; 2\cos(\pi/8)+2\cos(3\pi/8) \doteq 1/Q_4 \; .
\end{eqnarray}\end{split}\]</div>
<p>Note that <span class="math notranslate nohighlight">\(Q_4 \simeq 0.382683\)</span>. Then the poles occur on the unit circle at <span class="math notranslate nohighlight">\(s_k = \exp(i\theta_k)\)</span>, where</p>
<div class="math notranslate nohighlight">
\[\theta_k = \left\{ \frac{5\pi}{8} , \frac{7\pi}{8} , \frac{9\pi}{8} , \frac{11\pi}{8}\right\} \; .\]</div>
<p>In the general case, the poles can be computed using a numerical root-finding method.  In <a class="reference internal" href="#butter"><span class="std std-numref">Fig. 12</span></a> we show the root locus for different parameter variations away from the Butterworth case.</p>
<figure class="sphinx-subfigure align-center" id="butter">
<div class="sphinx-subfigure-grid ss-layout-default-ABC" style="display: grid; gap: 6px; grid-gap: 6px;">
<div class="sphinx-subfigure-area" style="display: flex; flex-direction: column; justify-content: center; align-items: center; grid-area: A;">
<img alt="_images/root-q.png" src="_images/root-q.png" />
</div>
<div class="sphinx-subfigure-area" style="display: flex; flex-direction: column; justify-content: center; align-items: center; grid-area: B;">
<img alt="_images/root-a.png" src="_images/root-a.png" />
</div>
<div class="sphinx-subfigure-area" style="display: flex; flex-direction: column; justify-content: center; align-items: center; grid-area: C;">
<img alt="_images/root-h.png" src="_images/root-h.png" />
</div>
</div>
<figcaption>
<p><span class="caption-number">Fig. 12 </span><span class="caption-text">Complex plane illustrating parabolic Weideman inversion contour for <span class="math notranslate nohighlight">\(\mu=1\)</span> and poles of the response function.  Baseline parameter values are those for the Butterworth filter, as defined in Eqs. <a class="reference internal" href="#equation-eq-but">(25)</a>.  Starting from the baseline values, we scan <span class="math notranslate nohighlight">\(\qt\)</span> in (a), <span class="math notranslate nohighlight">\(\alpha\)</span> in (b) and <span class="math notranslate nohighlight">\(h\)</span> in (c).  Plot (c) shows that large values of <span class="math notranslate nohighlight">\(h\)</span> can give rise to a pole crossing, which must be avoided.  Darker circles indicate larger values of the scanned parameter.</span><a class="headerlink" href="#butter" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The root loci illustrate that, for a Butterworth filter, <span class="math notranslate nohighlight">\(\mu &gt; 1\)</span> would be more than adequate to ensure that the parabolic contour always passes over the poles. However, in the limit of large tuning ratio, <span class="math notranslate nohighlight">\(h \gg 1\)</span>, which corresponds to port tuning much higher than the driver resonant frequency, the two poles associated with the port resonance can be shown to occur at <span class="math notranslate nohighlight">\(s \sim \pm i h -\alpha/(2h)\)</span>.  This behaviour is illustrated in <a class="reference internal" href="#butter"><span class="std std-numref">Fig. 12</span></a>.c.  Thus we would want to ensure that <span class="math notranslate nohighlight">\(\mu &gt; \max\left(1,h\right)\)</span>. Bearing these observations in mind, we can specify the required modifications to
Weideman’s algorithm as follows: choose a value of <span class="math notranslate nohighlight">\(N_0\)</span> to give desired integration accuracy at short time. Using this value of <span class="math notranslate nohighlight">\(N_0\)</span>, define the critical parameters</p>
<div class="math notranslate nohighlight" id="equation-eq-m1">
<span class="eqno">(26)<a class="headerlink" href="#equation-eq-m1" title="Link to this equation"></a></span>\[\mu_c \doteq \max\left\{1,h\right\} \quad \text{and} \quad t_c \doteq \frac{\pi N_0}{12 \mu_c} \; .\]</div>
<p>If <span class="math notranslate nohighlight">\(t &lt; t_c\)</span>, set</p>
<div class="math notranslate nohighlight" id="equation-eq-m2">
<span class="eqno">(27)<a class="headerlink" href="#equation-eq-m2" title="Link to this equation"></a></span>\[\mu = \frac{\pi N_0}{12 \, t} \;, \quad N = N_0 \; , \quad \Delta = \frac{3}{N}\]</div>
<p>Otherwise, for <span class="math notranslate nohighlight">\(t \geq t_c\)</span>, choose</p>
<div class="math notranslate nohighlight" id="equation-eq-m3">
<span class="eqno">(28)<a class="headerlink" href="#equation-eq-m3" title="Link to this equation"></a></span>\[\mu = \mu_c \; , \quad N = \left\lceil N_0 \, \frac{t}{t_c} \, \right\rceil \; , \quad \Delta = \frac{3}{N} \; ,\]</div>
<p>where <span class="math notranslate nohighlight">\(\lceil \cdot \rceil\)</span> is the ceiling function (i.e., the smallest integer greater than or equal to the argument). In other words, when <span class="math notranslate nohighlight">\(t &lt; t_c\)</span>, we decrease <span class="math notranslate nohighlight">\(\mu\)</span> at fixed <span class="math notranslate nohighlight">\(N\)</span> to stay on the optimal contour.  When <span class="math notranslate nohighlight">\(t &gt; t_c\)</span>, we must increase <span class="math notranslate nohighlight">\(N\)</span> to stay on the optimal contour for fixed <span class="math notranslate nohighlight">\(\mu_c\)</span>. In practice, the method is conservative insofar as <span class="math notranslate nohighlight">\(N\)</span> increases more rapidly than necessary to maintain accuracy.  For more complicated response functions, some method to determine the maximum height of the pole should be used, and that value should replace <span class="math notranslate nohighlight">\(h\)</span> in the previous formulae. Since the minimum height of the parabolic contour in the left half-plane is <span class="math notranslate nohighlight">\(y = 2 \mu\)</span>, the method above is conservative in that it ensures the contour is at least <em>double</em> the height of the highest pole.  To justify this choice, refer again to <a class="reference internal" href="#butter"><span class="std std-numref">Fig. 12</span></a> c.  The plot shows that not only will the choice <span class="math notranslate nohighlight">\(\mu=1\)</span> fail when <span class="math notranslate nohighlight">\(h &gt; 2\)</span>, but that as the pole nears the contour, the integrand will vary rapidly, giving a large error in the trapezoidal integration scheme.  Thus, the choice <span class="math notranslate nohighlight">\(\mu_c \doteq \max\left(1,h\right)\)</span> will ensure the contour is well-above the highest pole.</p>
</section>
<section id="result-with-viscoelastic-suspension">
<h2>Result with viscoelastic suspension<a class="headerlink" href="#result-with-viscoelastic-suspension" title="Link to this heading"></a></h2>
<p>To test the accuracy of the method for a more realistic case, we consider the previous vented box example but including the effects of viscoelastic compliance (suspension creep).  For the compliance function we choose the so-called <em>three-parameter creep</em> (3PC) model of Ritter and Agerkvist <span id="id15">[<a class="reference internal" href="zreferences.html#id45" title="T. Ritter and F. Agerkvist. Modelling viscoelasticity of loudspeaker suspensions using retardation spectra. J. Audio. Eng. Soc., 2010.">RA10</a>]</span>.</p>
<div class="math notranslate nohighlight" id="equation-eq-3pc">
<span class="eqno">(29)<a class="headerlink" href="#equation-eq-3pc" title="Link to this equation"></a></span>\[\cms \longrightarrow C_0 \left[ 1-\beta \ln \left( \frac{s}{s+s_0} \right) \right] \; .\]</div>
<p>The 3PC model includes both logarithmic creep and frequency-dependent damping. It is a generalization of the earlier LOG model of suspension creep <span id="id16">[<a class="reference internal" href="zreferences.html#id32" title="M.H. Knudsen and J.G. Jensen. Low-frequency loudspeaker models that include suspension creep. J. Audio. Eng. Soc., 41:3, 1993. URL: http://www.aes.org/e-lib/browse.cfm?elib=7015.">KJ93</a>]</span>, and introduces a parameter <span class="math notranslate nohighlight">\(s_0\)</span> to ensure that the frequency-dependent compliance <span class="math notranslate nohighlight">\(\cms(s)\)</span> is nonnegative at high frequency. The form of the compliance in Eq. <a class="reference internal" href="#equation-eq-3pc">(29)</a> is equivalent to the original form given in Ref. <span id="id17">[<a class="reference internal" href="zreferences.html#id45" title="T. Ritter and F. Agerkvist. Modelling viscoelasticity of loudspeaker suspensions using retardation spectra. J. Audio. Eng. Soc., 2010.">RA10</a>]</span>, but written more compactly.  Some aspects of the algebra required to establish the equivalence is given in the Appendix.  We further remark that in Eq. <a class="reference internal" href="#equation-eq-3pc">(29)</a>, <span class="math notranslate nohighlight">\(\beta\)</span> is the parameter of viscoelasticity (the creep parameter), which in the work by Ritter and Agerkvist (and the original work by Knudsen and Jensen) was represented by <span class="math notranslate nohighlight">\(\lambda\)</span>. The conversion between the representations is clarified in Appendix A.4 of Ref. <span id="id18">[<a class="reference internal" href="zreferences.html#id15" title="J. Candy and C. Futtrup. An Added-Mass Measurement Technique for Transducer Parameter Estimation. J. Audio. Eng. Soc., 65:1005, 2017. doi:10.17743/jaes.2017.0040.">CF17</a>]</span>.</p>
<p>Proceeding, the vented box response function can be modified to include the effects of viscoelasticity by writing</p>
<figure class="sphinx-subfigure align-center" id="fig-perror">
<div class="sphinx-subfigure-grid ss-layout-default-AB" style="display: grid; gap: 6px; grid-gap: 6px;">
<div class="sphinx-subfigure-area" style="display: flex; flex-direction: column; justify-content: center; align-items: center; grid-area: A;">
<img alt="_images/p.png" src="_images/p.png" />
</div>
<div class="sphinx-subfigure-area" style="display: flex; flex-direction: column; justify-content: center; align-items: center; grid-area: B;">
<img alt="_images/error.png" src="_images/error.png" />
</div>
</div>
<figcaption>
<p><span class="caption-number">Fig. 13 </span><span class="caption-text">Left plot shows time-domain step response <span class="math notranslate nohighlight">\(\xs(t)\)</span> corresponding to <span class="math notranslate nohighlight">\(R(s)\)</span> given in Eq. <a class="reference internal" href="#equation-eq-pcreep">(30)</a> with <span class="math notranslate nohighlight">\(h\)</span>, <span class="math notranslate nohighlight">\(\qt\)</span> and <span class="math notranslate nohighlight">\(\alpha\)</span> corresponding to the Butterworth values.  Time dependence is shown with creep (solid curve, <span class="math notranslate nohighlight">\(\beta=0.5\)</span>) and without creep (dotted curve, <span class="math notranslate nohighlight">\(\beta=0\)</span>. Right plot shows absolute error, <span class="math notranslate nohighlight">\(\Delta x_\mathrm{S} = | x_\mathrm{S}^{(N_0)}- x_\mathrm{S}^{(32)}|\)</span>, in inverse calculation for undamped vented box response function <span class="math notranslate nohighlight">\(R(z)\)</span>.  Here, <span class="math notranslate nohighlight">\(x_\mathrm{S}^{(N_0)}\)</span> refers to a numerical calculation with the given starting value <span class="math notranslate nohighlight">\(N_0\)</span>.</span><a class="headerlink" href="#fig-perror" title="Link to this image"></a></p>
</figcaption>
</figure>
<div class="math notranslate nohighlight" id="equation-eq-pcreep">
<span class="eqno">(30)<a class="headerlink" href="#equation-eq-pcreep" title="Link to this equation"></a></span>\[R(s) = \frac{s^4}{\displaystyle \left(s^2+h^2\right) \left( \frac{1}{c(s)} + \frac{s}{\qt} + s^2\right) + \alpha s^2} \; ,\]</div>
<p>where <span class="math notranslate nohighlight">\(c(s)\)</span> is an analytic function</p>
<div class="math notranslate nohighlight">
\[c(s) \doteq 1-\beta \ln \frac{s}{s+2} \; ,\]</div>
<p>that multiplies the static suspension compliance, <span class="math notranslate nohighlight">\(C_0\)</span>.  In this example, we have chosen <span class="math notranslate nohighlight">\(s_0=2\)</span>, corresponding to a transition frequency that is double the resonant frequency, but in practical cases other values may apply.  Note that when replacing the static compliance with the 3PC model, the meaning of <span class="math notranslate nohighlight">\(\rms\)</span> will change in response to the frequency-dependent damping effect (originating from the imaginary part of the logarithm). We emphasize that due to the branch cut <span class="math notranslate nohighlight">\(s \in [-2,0]\)</span>, the inverse transform of <span class="math notranslate nohighlight">\(R(s)/s\)</span> <em>cannot</em> be computed by traditional transform tables or a straightforward integration. <a class="reference internal" href="#fig-perror"><span class="std std-numref">Fig. 13</span></a> shows the time-domain step response as computed using the method of the present paper. The solid and dashed curves, respectively, show the response with and without the creep function.  We can also give
an indication of the resolution required to give acceptable results.  Also in <a class="reference internal" href="#fig-perror"><span class="std std-numref">Fig. 13</span></a> we plot the absolute inversion error as a function of the initial number of nodes, <span class="math notranslate nohighlight">\(N_0\)</span>.  We remark that eventually all curves overlap at sufficiently large <span class="math notranslate nohighlight">\(t\)</span> for which <span class="math notranslate nohighlight">\(\mu = 1\)</span>. These results show that the present method can compute the inverse efficiently to nearly machine precision.  In fact, in generating <a class="reference internal" href="#fig-perror"><span class="std std-numref">Fig. 13</span></a>, it was sufficient to use <span class="math notranslate nohighlight">\(N_0 \le 32\)</span>.  This is surprising given the apparent computational complexity of the integral in Eq. <a class="reference internal" href="#equation-eq-direct">(19)</a>.</p>
<p>Although the Fourier approach of Eq. <a class="reference internal" href="#equation-eq-dft">(21)</a> can be modified to give some accuracy improvement, it is manifestly less computationally efficient than the more elegant contour method. The latter with <span class="math notranslate nohighlight">\(N = 2 N_0 + 1 = 17\)</span> gives better accuracy than the Fourier method with <span class="math notranslate nohighlight">\(N = 8000\)</span>, and with <span class="math notranslate nohighlight">\(N = 65\)</span> points, the modified Weideman contour method returns an answer correct to nearly the full machine precision!</p>
</section>
<section id="nonlinear-driver-simulation">
<h2>Nonlinear driver simulation<a class="headerlink" href="#nonlinear-driver-simulation" title="Link to this heading"></a></h2>
<p>To illustrate how the present inversion method can be applied to time-domain simulation of (nonlinear) driven loudspeaker response, consider the time-domain differential equations that describe the driver displacement
<span class="math notranslate nohighlight">\(x(\tau)\)</span> <span id="id19">[<a class="reference internal" href="zreferences.html#id27" title="A.J.M. Kaizer. Modeling of the Nonlinear Response of an Electrodynamic Loudspeaker by a Volterra Series Expansion. J. Audio. Eng. Soc., 35:421, 1987.">Kai87</a>]</span>:</p>
<div class="math notranslate nohighlight" id="equation-eq-i">
<span class="eqno">(31)<a class="headerlink" href="#equation-eq-i" title="Link to this equation"></a></span>\[\begin{split}\begin{eqnarray}
V(\tau) &amp;=&amp; R_\mathrm{E} + L_\mathrm{E} \frac{dI}{d\tau} + \bl(x) \frac{dx}{d\tau} \; , \\
\bl(x) \, I &amp;=&amp; \mms \frac{d^2 x}{d\tau^2} + \rms \frac{dx}{d\tau} + \frac{x}{\cms} \; .
\end{eqnarray}\end{split}\]</div>
<p>Here, the unknown functions are <span class="math notranslate nohighlight">\(x(\tau)\)</span> and <span class="math notranslate nohighlight">\(I(\tau)\)</span>, with <span class="math notranslate nohighlight">\(V(\tau)\)</span> a known driving voltage.  Also, <span class="math notranslate nohighlight">\(R_\mathrm{E}\)</span> and <span class="math notranslate nohighlight">\(L_\mathrm{E}\)</span> are the voice coil resistance and inductance, <span class="math notranslate nohighlight">\(\mms\)</span> is the moving mass, <span class="math notranslate nohighlight">\(\rms\)</span> is the suspension damping, and <span class="math notranslate nohighlight">\(\cms\)</span> the suspension compliance.  In these equations, the force-factor <span class="math notranslate nohighlight">\(\bl(x)\)</span> can be considered to be a nonlinear
function of <span class="math notranslate nohighlight">\(x\)</span>.  Normally, viscoelastic compliance is not modeled because of the difficulty in treating the rightmost compliance term above. However, according to the present formulation, we should replace the term <span class="math notranslate nohighlight">\(x/\cms\)</span> with</p>
<div class="math notranslate nohighlight">
\[{\cal L}^{-1} \left[  \frac{X(s)}{C_0} \frac{1}{1+\beta\ln(1+s_0/s)} \right] \; ,\]</div>
<p>where <span class="math notranslate nohighlight">\(C_0\)</span> is a new constant compliance, <span class="math notranslate nohighlight">\(\beta\)</span> is a measure of the strength of the viscoelastic behaviour, and <span class="math notranslate nohighlight">\(s_0\)</span> is a parameter that characterizes the transition frequency between viscoelastic <span class="math notranslate nohighlight">\((s &lt; s_0)\)</span> and simple elastic <span class="math notranslate nohighlight">\((s \gg s_0)\)</span> behaviour.  Here, we have introduced the Laplace variable <span class="math notranslate nohighlight">\(s\)</span> corresponding to the dimensionless time <span class="math notranslate nohighlight">\(t = \omega_s \tau\)</span>, such that <span class="math notranslate nohighlight">\(\omega_s \doteq 1/\sqrt{\mms C_0}\)</span> is the resonant frequency of the system in the limit <span class="math notranslate nohighlight">\(\beta \rightarrow 0\)</span>. We can rearrange terms slightly to write the required inverse transform as</p>
<div class="math notranslate nohighlight">
\[\frac{x(t)}{C_0} - \frac{\beta}{C_0} {\cal L}^{-1} \left[ G(s) X(s) \right] \; ,\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[G(s) \doteq \frac{\ln(1+s_0/s)}{1+\beta \ln(1+s_0/s)} \; .\]</div>
<p>According to the convolution theorem, the time domain response can be written explicitly as</p>
<div class="math notranslate nohighlight" id="equation-eq-conv">
<span class="eqno">(32)<a class="headerlink" href="#equation-eq-conv" title="Link to this equation"></a></span>\[\frac{x(t)}{C_0} - \frac{\beta}{C_0} \int_0^t d\tp \, g(t-\tp) x(\tp) \; ,\]</div>
<p>where <span class="math notranslate nohighlight">\(g(t) = {\cal L}^{-1} [G(s)]\)</span>.  Thus, the original differential equations describing <span class="math notranslate nohighlight">\(x(\tau)\)</span> and <span class="math notranslate nohighlight">\(I(\tau)\)</span> are transformed into integro-differential form.  For completeness, we note that the modified equation for the transducer motion is</p>
<div class="math notranslate nohighlight">
\[f(t) = \ddot{x} + \frac{\dot{x}}{\qms} + x - \beta \displaystyle \int_0^t d\tp \, g(t-\tp) x(\tp) \; .\]</div>
<p>where <span class="math notranslate nohighlight">\(f = C_0 \bl(x) I(t)\)</span> is a normalized force (with the same units as the displacement), and a dot denotes a time derivative, as in Sec.~1. The effect of viscoelasticity is reflected in the convolution
integral above.  The integral samples the entire time history <span class="math notranslate nohighlight">\(x(\tp)\)</span> for <span class="math notranslate nohighlight">\(0 \le \tp \le t\)</span>, which reflects the memory effect inherent to viscoelastic materials.  The memory is controlled by the kernel <span class="math notranslate nohighlight">\(g\)</span>; systems with weak memory will have <span class="math notranslate nohighlight">\(g\)</span> that decays rapidly. With the proposed modified Weideman contour method, the inverse transform <span class="math notranslate nohighlight">\(g(t)\)</span> can be computed to machine precision at any desired values of <span class="math notranslate nohighlight">\(t\)</span>.  Sample plots of <span class="math notranslate nohighlight">\(g(t)\)</span> for different values of <span class="math notranslate nohighlight">\(\beta\)</span> are shown in <a class="reference internal" href="#ft"><span class="std std-numref">Fig. 14</span></a>. Finally, it is worth noting that in the limit <span class="math notranslate nohighlight">\(\beta \rightarrow 0\)</span> we can carry out the inverse transform exactly according to</p>
<div class="math notranslate nohighlight">
\[g(t) \sim {\cal L}^{-1} \left[ \ln(1+s_0/s) \right] = \frac{1-e^{-s_0 t}}{t} \; .\]</div>
<p>The addition of the convolution to the time-domain formulation is analogous to the more formal state-space approach of King <span id="id20">[<a class="reference internal" href="zreferences.html#id30" title="A. King and F. Agerkvist. State-Space Modeling of Loudspeakers using Fractional Derivatives. J. Audio. Eng. Soc. (abstracts), 2015.">KA15</a>]</span> that focuses exclusively on a fractional derivative model of compliance.  In the case of fractional derivatives, however, the inverse transform <span class="math notranslate nohighlight">\(g(t)\)</span> can be computed analytically, and the convolution written as a Riemann-Liouville fractional integral.</p>
<figure class="sphinx-subfigure align-center" id="ft" style="width: 50%">
<div class="sphinx-subfigure-grid ss-layout-default-A" style="display: grid;">
<div class="sphinx-subfigure-area" style="display: flex; flex-direction: column; justify-content: center; align-items: center; grid-area: A;">
<img alt="_images/ft.png" src="_images/ft.png" />
</div>
</div>
<figcaption>
<p><span class="caption-number">Fig. 14 </span><span class="caption-text">Convolution kernel function <span class="math notranslate nohighlight">\(g(t) = {\cal L}^{-1} [G(s)]\)</span> of Eq. <a class="reference internal" href="#equation-eq-conv">(32)</a> as computed by the Weideman inversion method. Plots are shown for <span class="math notranslate nohighlight">\(s_0=2\)</span> and four values of <span class="math notranslate nohighlight">\(\beta\)</span>.</span><a class="headerlink" href="#ft" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="summary-of-inversion-method">
<h2>Summary of inversion method<a class="headerlink" href="#summary-of-inversion-method" title="Link to this heading"></a></h2>
<p>In these notes we have outlined a modification to the Weideman method for numerical calculation of the inverse Laplace transform.  The modified method is suitable for calculating the time-domain loudspeaker response and can
be implemented in only a few lines of code.  The complete algorithm is summarized by Eqs. <a class="reference internal" href="#equation-eq-trap">(23)</a>, <a class="reference internal" href="#equation-eq-m1">(26)</a>, <a class="reference internal" href="#equation-eq-m2">(27)</a> and <a class="reference internal" href="#equation-eq-m3">(28)</a>.  Importantly, it can be applied to nonstandard frequency-domain response functions containing branch cuts, as encountered in advanced transducer models with semi-inductance in the motor or viscoelasticity in the suspension. Alternatively, this method can be used as a simple and rapid method to compute the time-domain response for simple polynomial response functions.</p>
</section>
<section id="appendices">
<h2>Appendices<a class="headerlink" href="#appendices" title="Link to this heading"></a></h2>
<section id="simplification-of-the-ritter-3pc-compliance-model">
<h3>Simplification of the Ritter 3PC compliance model<a class="headerlink" href="#simplification-of-the-ritter-3pc-compliance-model" title="Link to this heading"></a></h3>
<p>In Eq. (13) of a paper by Ritter and Agerkvist <span id="id21">[<a class="reference internal" href="zreferences.html#id45" title="T. Ritter and F. Agerkvist. Modelling viscoelasticity of loudspeaker suspensions using retardation spectra. J. Audio. Eng. Soc., 2010.">RA10</a>]</span>, the viscoelastic compliance contains a logarithmic term that is expressed as</p>
<div class="math notranslate nohighlight">
\[\log_{10} \left[ \frac{i \omega \tau_\mathrm{min} e^{-i \beta}}{\sqrt{1+\omega^2\tau_\mathrm{min}^2}} \right] \; .\]</div>
<p>In this expression, <span class="math notranslate nohighlight">\(\beta=\tan^{-1}(\tau_\mathrm{min} \omega)\)</span> is the phase angle. We remark that Ritter’s <span class="math notranslate nohighlight">\(\beta\)</span> is unrelated to <span class="math notranslate nohighlight">\(\beta\)</span> in these notes.  By defining <span class="math notranslate nohighlight">\(s_0 \doteq 1/\tau_\mathrm{min}\)</span>, setting <span class="math notranslate nohighlight">\(s=i\omega\)</span>, and expanding the complex exponential, we can rewrite this as</p>
<div class="math notranslate nohighlight">
\[\log_{10} \left[ \frac{(s/s_0)}{\sqrt{1-s^2/s_0^2}} \left( \cos\beta - i \sin\beta\right) \right] \; .\]</div>
<p>Next, using the identities</p>
<div class="math notranslate nohighlight">
\[\sin\beta = \frac{\omega/s_0}{\sqrt{1+\omega^2/s_0^2}} \; ,
\quad
\cos\beta = \frac{1}{\sqrt{1+\omega^2/s_0^2}} \; ,\]</div>
<p>which follow from <span class="math notranslate nohighlight">\(\tan\beta = \omega/s_0\)</span>, we can write the argument as</p>
<div class="math notranslate nohighlight">
\[\log_{10} \left[ \frac{(s/s_0) \left( 1-s/s_0 \right)}{1-s^2/s_0^2} \right] =
\log_{10} \left( \frac{s}{s+s_0} \right) \; ,\]</div>
<p>which is the argument used in Eq. <a class="reference internal" href="#equation-eq-3pc">(29)</a>.</p>
</section>
<section id="sample-python-code-for-inverse-transform">
<h3>Sample Python code for inverse transform<a class="headerlink" href="#sample-python-code-for-inverse-transform" title="Link to this heading"></a></h3>
<p>The following Python code implements the algorithm of Eq. <a class="reference internal" href="#equation-eq-trap">(23)</a> as applied to the closed box response function of Eq. <a class="reference internal" href="#equation-eq-hp2">(15)</a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="linenos"> 2</span><span class="kn">import</span> <span class="nn">time</span>
<span class="linenos"> 3</span>
<span class="linenos"> 4</span><span class="k">def</span> <span class="nf">y</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="linenos"> 5</span>    <span class="n">qts</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="linenos"> 6</span>    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="linenos"> 7</span>    <span class="n">y</span> <span class="o">=</span> <span class="n">s</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="n">s</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">s</span><span class="o">/</span><span class="n">qts</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">alpha</span><span class="p">)</span>
<span class="linenos"> 8</span>    <span class="k">return</span> <span class="n">y</span>
<span class="linenos"> 9</span>              
<span class="linenos">10</span><span class="k">def</span> <span class="nf">step</span><span class="p">():</span>
<span class="linenos">11</span>
<span class="linenos">12</span>   <span class="c1">#------------------------------------------------------------</span>
<span class="linenos">13</span>   <span class="c1"># Some adjustable settings</span>
<span class="linenos">14</span>
<span class="linenos">15</span>   <span class="c1"># Number of time points</span>
<span class="linenos">16</span>   <span class="n">nt</span> <span class="o">=</span> <span class="mi">400</span>
<span class="linenos">17</span>
<span class="linenos">18</span>   <span class="c1"># Initial number of integration nodes along parabola</span>
<span class="linenos">19</span>   <span class="n">N0</span> <span class="o">=</span> <span class="mi">16</span>
<span class="linenos">20</span>
<span class="linenos">21</span>   <span class="c1"># Max(ws*t) = total integration time (t_max in AES paper)</span>
<span class="linenos">22</span>   <span class="n">tmax</span> <span class="o">=</span> <span class="mf">8.0</span>
<span class="linenos">23</span>   <span class="c1">#------------------------------------------------------------</span>
<span class="linenos">24</span>
<span class="linenos">25</span>   <span class="n">mu_c</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>
<span class="linenos">26</span>   <span class="n">t_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">N0</span><span class="o">/</span><span class="p">(</span><span class="mi">12</span><span class="o">*</span><span class="n">mu_c</span><span class="p">)</span>
<span class="linenos">27</span>
<span class="linenos">28</span>   <span class="c1"># Pack points closer to t=0</span>
<span class="linenos">29</span>   <span class="n">tvec</span> <span class="o">=</span> <span class="n">tmax</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1e-4</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="n">nt</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="linenos">30</span>   <span class="n">svec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
<span class="linenos">31</span>   
<span class="linenos">32</span>   <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
<span class="linenos">33</span>
<span class="linenos">34</span>      <span class="n">t</span> <span class="o">=</span> <span class="n">tvec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
<span class="linenos">35</span>
<span class="linenos">36</span>      <span class="k">if</span> <span class="n">t</span><span class="o">&lt;</span><span class="n">t_c</span><span class="p">:</span>
<span class="linenos">37</span>         <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">N0</span><span class="o">/</span><span class="p">(</span><span class="mf">12.0</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="linenos">38</span>         <span class="n">N</span> <span class="o">=</span> <span class="n">N0</span>
<span class="linenos">39</span>      <span class="k">else</span><span class="p">:</span>
<span class="linenos">40</span>         <span class="n">mu</span> <span class="o">=</span> <span class="n">mu_c</span>
<span class="linenos">41</span>         <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">N0</span><span class="o">*</span><span class="n">t</span><span class="o">/</span><span class="n">t_c</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
<span class="linenos">42</span>
<span class="linenos">43</span>      <span class="n">d</span> <span class="o">=</span> <span class="mf">3.0</span><span class="o">/</span><span class="n">N</span>
<span class="linenos">44</span>  
<span class="linenos">45</span>      <span class="c1"># Vectorize over contour sum</span>
<span class="linenos">46</span>      <span class="n">u</span> <span class="o">=</span> <span class="n">d</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="linenos">47</span>      <span class="n">s</span> <span class="o">=</span> <span class="n">mu</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">u</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="linenos">48</span>      <span class="n">dsdu</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">-</span><span class="n">u</span><span class="p">)</span>
<span class="linenos">49</span>      <span class="n">step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">s</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">/</span><span class="n">s</span><span class="o">*</span><span class="n">dsdu</span><span class="p">))</span><span class="o">*</span><span class="n">d</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> 
<span class="linenos">50</span>      
<span class="linenos">51</span>      <span class="c1"># step response</span>
<span class="linenos">52</span>      <span class="n">svec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">step</span>
<span class="linenos">53</span>
<span class="linenos">54</span>   <span class="k">return</span> <span class="n">tvec</span><span class="p">,</span><span class="n">svec</span>
<span class="linenos">55</span>
<span class="linenos">56</span><span class="n">t</span><span class="p">,</span><span class="n">s</span> <span class="o">=</span> <span class="n">step</span><span class="p">()</span>
<span class="linenos">57</span>
<span class="linenos">58</span><span class="n">exact</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span>
<span class="linenos">59</span><span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="linenos">60</span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:.3f}</span><span class="s1"> </span><span class="si">{:.4f}</span><span class="s1"> </span><span class="si">{:.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">exact</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
</pre></div>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="cd4.html" class="btn btn-neutral float-left" title="The CD4 Bass Reflex Alignment" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="sampledata.html" class="btn btn-neutral float-right" title="Sample Data" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2025 | C. Futtrup and J. Candy.
      <span class="lastupdated">Last updated on Feb 01, 2025.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>